import { AIUsageMetrics } from '../types/ai.js';
import { SessionAnalytics } from '../services/sessionAnalytics.js';
import { FileSystem } from '../utils/fileSystem.js';
import { Logger } from '../utils/logger.js';

/**
 * Generate comprehensive cost and analytics reports
 */
export class CostReportGenerator {
  
  /**
   * Generate cost report markdown
   */
  static generateCostReport(metrics: AIUsageMetrics, analytics: any): string {
    const duration = metrics.endTime 
      ? (metrics.endTime.getTime() - metrics.startTime.getTime()) / 60000 
      : 0;
    
    // Calculate cost breakdown by type
    const costByType: Record<string, number> = {};
    metrics.interactions.forEach(interaction => {
      costByType[interaction.type] = (costByType[interaction.type] || 0) + interaction.cost;
    });

    // Calculate cost per metric
    const costPerQuestion = analytics.questionsAnswered > 0 
      ? metrics.estimatedCost / analytics.questionsAnswered 
      : 0;
    const costPerFile = analytics.filesGenerated.length > 0
      ? metrics.estimatedCost / analytics.filesGenerated.length
      : 0;
    const costPerMinute = duration > 0 ? metrics.estimatedCost / duration : 0;

    // Calculate ROI estimate (assuming 2 hours saved at $50/hour)
    const timeSavedHours = 2;
    const hourlyRate = 50;
    const estimatedValue = timeSavedHours * hourlyRate;
    const roi = metrics.estimatedCost > 0 
      ? ((estimatedValue - metrics.estimatedCost) / metrics.estimatedCost * 100).toFixed(1)
      : '∞';

    return `# Session Cost Report

## Session Information
- **Session ID:** ${analytics.sessionId}
- **Date:** ${metrics.startTime.toLocaleDateString()}
- **Duration:** ${duration.toFixed(1)} minutes
- **Session Type:** ${analytics.sessionType}

## API Usage Summary
- **Total API Calls:** ${metrics.apiCalls}
- **Total Tokens:** ${metrics.totalTokensUsed.toLocaleString()}
  - Input Tokens: ${metrics.inputTokens.toLocaleString()}
  - Output Tokens: ${metrics.outputTokens.toLocaleString()}
- **Model:** ${metrics.model}

## Cost Breakdown

### Total Cost
**$${metrics.estimatedCost.toFixed(4)} USD**

### Cost by Feature
${Object.entries(costByType)
  .sort((a, b) => b[1] - a[1])
  .map(([type, cost]) => {
    const percent = (cost / metrics.estimatedCost * 100).toFixed(1);
    return `- **${this.formatFeatureName(type)}:** $${cost.toFixed(4)} (${percent}%)`;
  })
  .join('\n')}

### Cost Efficiency Metrics
- **Cost per Question:** $${costPerQuestion.toFixed(4)}
- **Cost per Generated File:** $${costPerFile.toFixed(4)}
- **Cost per Minute:** $${costPerMinute.toFixed(4)}

## Interaction Details

### By Type
${Object.entries(costByType).map(([type, _cost]) => {
  const interactions = metrics.interactions.filter(i => i.type === type);
  return `
#### ${this.formatFeatureName(type)}
- Calls: ${interactions.length}
- Avg Tokens: ${this.calculateAvgTokens(interactions).toFixed(0)}
- Total Cost: $${interactions.reduce((sum, i) => sum + i.cost, 0).toFixed(4)}`;
}).join('\n')}

## Session Efficiency Analysis

### Time Savings
- **Estimated Time Saved:** ${timeSavedHours} hours
- **Value of Time Saved:** $${estimatedValue}
- **API Cost:** $${metrics.estimatedCost.toFixed(4)}
- **Net Value:** $${(estimatedValue - metrics.estimatedCost).toFixed(2)}
- **ROI:** ${roi}%

### Quality Improvements
- **Validation Score:** ${analytics.validationScore}%
- **AI Suggestions Accepted:** ${analytics.aiSuggestionsAccepted}/${analytics.aiInterventions} (${
  analytics.aiInterventions > 0 
    ? (analytics.aiSuggestionsAccepted / analytics.aiInterventions * 100).toFixed(1) 
    : 0
}%)
- **Optimizations Performed:** ${analytics.aiOptimizationsPerformed}

## Budget Analysis
${this.generateBudgetAnalysis(metrics)}

## Recommendations
${this.generateRecommendations(metrics, analytics)}

---
*Generated by prd-zero | ${new Date().toLocaleString()}*
`;
  }

  /**
   * Generate JSON cost report
   */
  static generateCostJSON(metrics: AIUsageMetrics, analytics: any): object {
    const costByType: Record<string, number> = {};
    const tokensByType: Record<string, { input: number; output: number }> = {};
    
    metrics.interactions.forEach(interaction => {
      costByType[interaction.type] = (costByType[interaction.type] || 0) + interaction.cost;
      
      if (!tokensByType[interaction.type]) {
        tokensByType[interaction.type] = { input: 0, output: 0 };
      }
      tokensByType[interaction.type].input += interaction.inputTokens;
      tokensByType[interaction.type].output += interaction.outputTokens;
    });

    return {
      session: {
        id: analytics.sessionId,
        timestamp: metrics.startTime.toISOString(),
        duration: analytics.duration,
        type: analytics.sessionType,
      },
      usage: {
        totalCost: metrics.estimatedCost,
        apiCalls: metrics.apiCalls,
        totalTokens: metrics.totalTokensUsed,
        inputTokens: metrics.inputTokens,
        outputTokens: metrics.outputTokens,
        model: metrics.model,
      },
      costBreakdown: {
        byType: costByType,
        perQuestion: analytics.questionsAnswered > 0 
          ? metrics.estimatedCost / analytics.questionsAnswered 
          : 0,
        perFile: analytics.filesGenerated.length > 0
          ? metrics.estimatedCost / analytics.filesGenerated.length
          : 0,
      },
      tokenBreakdown: tokensByType,
      interactions: metrics.interactions.map(i => ({
        type: i.type,
        timestamp: i.timestamp,
        cost: i.cost,
        tokens: {
          input: i.inputTokens,
          output: i.outputTokens,
        },
      })),
      efficiency: {
        questionsAnswered: analytics.questionsAnswered,
        filesGenerated: analytics.filesGenerated.length,
        validationScore: analytics.validationScore,
        aiSuggestionsAccepted: analytics.aiSuggestionsAccepted,
        aiSuggestionsRejected: analytics.aiSuggestionsRejected,
      },
    };
  }

  /**
   * Save all cost reports
   */
  static async saveCostReports(
    outputDir: string,
    metrics: AIUsageMetrics,
    analytics: SessionAnalytics
  ): Promise<void> {
    try {
      // Generate reports
      const markdownReport = this.generateCostReport(metrics, analytics);
      const jsonReport = this.generateCostJSON(metrics, analytics);

      // Save markdown report
      const mdPath = FileSystem.getOutputPath(outputDir, 'ai-cost-report.md');
      await FileSystem.writeFile(mdPath, markdownReport);
      
      // Save JSON report
      const jsonPath = FileSystem.getOutputPath(outputDir, 'ai-costs.json');
      await FileSystem.saveJSON(jsonPath, jsonReport);

      Logger.success(`Cost reports saved to session folder`);
    } catch (error) {
      Logger.error(`Failed to save cost reports: ${error}`);
    }
  }

  /**
   * Format feature name for display
   */
  private static formatFeatureName(type: string): string {
    const names: Record<string, string> = {
      challenge: 'Question Challenging',
      optimize: 'Content Optimization',
      suggest: 'Improvement Suggestions',
      validate: 'Answer Validation',
      enhance: 'Content Enhancement',
    };
    return names[type] || type.charAt(0).toUpperCase() + type.slice(1);
  }

  /**
   * Calculate average tokens for interactions
   */
  private static calculateAvgTokens(interactions: any[]): number {
    if (interactions.length === 0) return 0;
    const total = interactions.reduce((sum, i) => sum + i.inputTokens + i.outputTokens, 0);
    return total / interactions.length;
  }

  /**
   * Generate budget analysis section
   */
  private static generateBudgetAnalysis(metrics: AIUsageMetrics): string {
    // Assuming a default budget of $1.00 if not specified
    const budget = 1.00;
    const percentUsed = (metrics.estimatedCost / budget * 100).toFixed(1);
    const remaining = budget - metrics.estimatedCost;
    
    let status = '✅ Within Budget';
    if (metrics.estimatedCost > budget) {
      status = '❌ Over Budget';
    } else if (metrics.estimatedCost > budget * 0.8) {
      status = '⚠️ Near Budget Limit';
    }

    return `
- **Budget:** $${budget.toFixed(2)}
- **Used:** $${metrics.estimatedCost.toFixed(4)} (${percentUsed}%)
- **Remaining:** $${remaining.toFixed(4)}
- **Status:** ${status}`;
  }

  /**
   * Generate recommendations based on usage
   */
  private static generateRecommendations(metrics: AIUsageMetrics, analytics: SessionAnalytics): string {
    const recommendations: string[] = [];
    
    // Cost efficiency recommendations
    const avgCostPerCall = metrics.estimatedCost / metrics.apiCalls;
    if (avgCostPerCall > 0.01) {
      recommendations.push('- Consider using Claude Haiku for lower-cost operations');
    }
    
    // Token usage recommendations
    const avgTokensPerCall = metrics.totalTokensUsed / metrics.apiCalls;
    if (avgTokensPerCall > 2000) {
      recommendations.push('- Optimize prompts to reduce token usage');
    }
    
    // Acceptance rate recommendations
    if (analytics.aiInterventions > 0) {
      const acceptanceRate = analytics.aiSuggestionsAccepted / analytics.aiInterventions;
      if (acceptanceRate < 0.5) {
        recommendations.push('- AI suggestions have low acceptance rate - consider adjusting AI behavior');
      }
    }
    
    // General recommendations
    if (metrics.estimatedCost < 0.10) {
      recommendations.push('- Excellent cost efficiency achieved!');
    }
    
    if (analytics.validationScore < 60) {
      recommendations.push('- Consider more AI assistance during planning for better validation scores');
    }

    return recommendations.length > 0 
      ? recommendations.join('\n')
      : '- Session completed efficiently with good cost management';
  }
}